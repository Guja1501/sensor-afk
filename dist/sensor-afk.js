(()=>{var u=(r,t)=>()=>(t||r((t={exports:{}}).exports,t),t.exports);var n=u((c,i)=>{i.exports=class s{constructor(t={}){s.initStatic();let{time:o,sensors:e,node:h,callback:a}=s.filterOptions(t);this.node=h,this.time=o,this.callback=a,this.sensors=Array.isArray(e)?e:e.split(" "),this.timeout=null,this.statusOn=!0,this.flush(),this.eventRegistration()}static initStatic(){if(this.initStaticDone===!0)return!0;this.initStaticDone=!0,this.defaultOptions={time:30,sensors:"click wheel mousemove keydown keyup keypress",node:document,callback:()=>{}},this.events={afk:new Event("SensorAFK:AFK"),flush:new Event("SensorAFK:flush"),stop:new Event("SensorAFK:stop"),start:new Event("SensorAFK:start")}}static filterOptions(t={}){return Object.assign({},s.defaultOptions,t)}get seconds(){return this.time*1e3}trigger(t){this.node.dispatchEvent(t)}flush(){this.statusOn&&(this.trigger(s.events.flush),this.stop().start())}stop(){if(this.trigger(s.events.stop),this.timeout!==null)try{clearTimeout(this.timeout)}catch{}finally{this.timeout=null}return this}start(){return this.trigger(s.events.start),this.timeout=setTimeout(()=>{this.afk()},this.seconds),this}afk(){return this.statusOn?(this.trigger(s.events.afk),this.callback(),this):this}eventRegistration(){for(let t of this.sensors)this.node.addEventListener(t,this.flush.bind(this),!1)}off(){this.statusOn=!1}on(){this.statusOn=!0}toggle(){this.statusOn=!this.statusOn}}});window.SensorAFK=n();})();
